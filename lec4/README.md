## 課題１について
幅優先探索で最短経路を探索していく。
1. 入力されたスタートとゴールのタイトルに対して、`get_id_from_title()`でIDを取得する
2. キューにスタートをエンキューする。
3. visited辞書には親ノードのIDとスタートからの移動回数を保存する。スタートの親はNone, countは0とする。
4. キューにノードが存在する限り、デキューしたノードに対して以下を行う。
    - ノードがゴールと一致した場合は`titles`に自分のタイトルを追加し、親ノードが存在する限り、親ノードのタイトルを`titles`の先頭に入れていく。
    - 持っている子ノードに対して、visitedに入っていない場合は親ノードを自分、countを`自分のcount+1`として追加し、キューにエンキューする。


## 課題２について
1. `new_pagerank{}`はすべて0.0, `old_pagerank{}`はすべて1.0で初期化する。
2. 以下の手順を繰り返す。
    - 全ページに配布する`handout_pagerank`を0.0に初期化する。
    - 各ページに対して、以下を行う。
        - 子ページが存在する場合は`old_pagerank`の自分のページランクの0.85倍を子ページの`new_pagerank`に分配し、残りの0.15倍は`handout_pagerank`に加算する。
        - 子ページが存在しない場合は`old_pagerank`の自分のページランクをすべて`handout_pagerank`に加算する。
    - `handout_pagerank`を全ページの`new_pagerank`に配布する。
    - `calc_pagerank_diff()`を用いて、`old_pagerank`と`new_pagerank`の距離を計算する。
        - 距離が0.01を下回った場合、終了。
        - 距離が0.01を上回った場合、`new_pagerank`の各ページランクを`old_pagerank`にコピーし、`new_pagerank`は0.0とする。
3. `new_pagerank`をページランク降順になるようにソートする。
4. 存在する限り上位10件をprintする。